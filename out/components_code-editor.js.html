<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/code-editor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/code-editor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import store from "../data/store.js";
import CommentsMarkerComponent from "./comments-marker.js";
import Vue from "https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js";

/**
 * Vue-Component to display the code and comments together.
 * Depends on vue-codemirror, codemirror and side-comments.
 *
 * Adds Hooks for side-comments to codemirror.
 * Handles display and interaction of and with the comments.
 * Handles display of the code.
 * Holds the configuration for codemirror.
 * 
 * @module components/CodeEditorComponent
 * @author Fabian Zeiher &lt;fzeiher@gmail.com>
 * @requires module:data/store
 */
/**
 * Namespace Object for Code Editor Component.
 * @namespace
 */
var CodeEditorComponent = {
    /** Css-selector for component template.
     * @type {String}
     */
    template: "#code-editor-component-template",
    /** Hold reactive data for the component.
     * Utilizing Vues built in reactivity the component will re-render if this data changes, see link below.
     * @property {module:data/store~State} sharedState - Reference to the state object in order to utilize Vues built in reactivity for automatic re-render.
     * @property {Object} cmOption - Codemirror configuration object.
     * @property {String} linePaddingRight - Right padding for codemirror lines in css terminology (e.g. "20px").
     * @see https://vuejs.org/v2/guide/reactivity.html
     */
    data() {
        return {
            sharedState: store.state,
            cmOption: {
                placeholder: "nothing here :(",
                mode: "javascript",
                readOnly: true,
                lineNumbers: true,
                scrollbarStyle: "simple",
                foldGutter: true,
                scrollPastEnd: true,
                styleSelectedText: true,
                highlightSelectionMatches: {showToken: /\w/, annotateScrollbar: true},
                matchBrackets: true,
                // viewportMargin: Infinity,
            },
            linePaddingRight: "22px",
        };
    },
    /** Hold computed properties for the component.
     * @property {Object} codemirror - The current codemirror instance.
     * @property {String} code - Get current code string from shared state.
     */
    computed: {
        codemirror() {
          return this.$refs.cmEditor.codemirror;
        },
        code() {
           return this.sharedState.content.files[this.sharedState.content.currentFile].text;
        },
    },
    /**
     * Code to execute when component is mounted, reference Vue Lifecycle below.
     * Add Comment Marker Components as LineWidgets. Listen for events from codemirror to handle rerender and content changes.
     * @see https://vuejs.org/v2/guide/instance.html
     */
    mounted() {
        /*
        Object to store a flexible amount of reusable Marker Components.
        The Runtime initialization of Vue Components is expensive, this caused performace issues with codemirror since the dom is re-rendered often.
        This object stores the Vue Components so on codemirror re-render the components are just re-added to the DOM, but not re-instanciated.
        Since the Components themselfes are complete reactive, they will change there content according to the application state automatically.
        */
        const dynamicMarkerComponentList = {
            componentClass: Vue.extend(CommentsMarkerComponent),
            items: [],
            createComponentElement(sectionId) {
                let instance = new this.componentClass({
                    propsData: {section: sectionId},
                });
                // vue component is rendered at the end of the dom
                // component can later be injected into codemirror as a line-widget
                instance.$mount();
                return instance.$el;
            },
            setLength(length) {
                // add components if there are not enouph
                if (this.items.length &lt; length) {
                    for (let i = this.items.length; i &lt;= length; i++) {
                        this.items.push(this.createComponentElement(i.toString()));
                    }
                // remove components if there are a lot to many
                } else if (this.items.length > length + 100) {
                    this.items.splice(length);
                }
                console.log("Current amount of stored Marker-Components: " + this.items.length);
            },
        },
        // Manually adds marker components to codemirror once, because codemirror.on("change") is not called when the editor ist started.
        initOnce = () => {
            dynamicMarkerComponentList.setLength(this.codemirror.lineCount());
            for (let i = 0; i &lt; this.codemirror.lineCount(); i++) {
                this.codemirror.addLineWidget(i, dynamicMarkerComponentList.items[i], { handleMouseEvents: true});
            }
        };

        // Re-add comment marker elements to codemirror when the editors content changes.
        // Marker elements get reused for performance reasons.
        this.codemirror.on("change", () => {
            dynamicMarkerComponentList.setLength(this.codemirror.lineCount());
            for (let i = 0; i &lt; this.codemirror.lineCount(); i++) {
                this.codemirror.addLineWidget(i, dynamicMarkerComponentList.items[i], { handleMouseEvents: true});
            }
        });
        
        // Add padding for the side-comments button on every codemirror line.
        // Necessary to avoid drawing the button on top of code. Additionally avoids click trough onto code.
        this.codemirror.on("renderLine", (instance, lineHandle, element) => {
            element.setAttribute("style", "padding-right: " + this.linePaddingRight);
        });

        initOnce();
    },
};

export default CodeEditorComponent;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-components_CodeEditorComponent.html">components/CodeEditorComponent</a></li><li><a href="module-components_CommentsDisplayComponent.html">components/CommentsDisplayComponent</a></li><li><a href="module-components_CommentsMarkerComponent.html">components/CommentsMarkerComponent</a></li><li><a href="module-data_store.html">data/store</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-components_CodeEditorComponent-CodeEditorComponent.html">CodeEditorComponent</a></li><li><a href="module-components_CommentsDisplayComponent-CommentsDisplayComponent.html">CommentsDisplayComponent</a></li><li><a href="module-components_CommentsMarkerComponent-CommentsMarkerComponent.html">CommentsMarkerComponent</a></li><li><a href="module-data_store-store.html">store</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sun Oct 18 2020 20:26:31 GMT+0200 (GMT+02:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
